// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/core/framework/graph.proto

package org.tensorflow.framework;

/**
 * <pre>
 * Represents the graph of operations
 * </pre>
 * <p>
 * Protobuf type {@code tensorflow.GraphDef}
 */
public final class GraphDef extends
                            com.google.protobuf.GeneratedMessageV3 implements
                                                                   // @@protoc_insertion_point(message_implements:tensorflow.GraphDef)
                                                                           GraphDefOrBuilder {
    private static final long serialVersionUID = 0L;

    // Use GraphDef.newBuilder() to construct.
    private GraphDef(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
    }

    private GraphDef() {
        node_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
            UnusedPrivateParameter unused) {
        return new GraphDef();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
        return this.unknownFields;
    }

    public static final com.google.protobuf.Descriptors.Descriptor
    getDescriptor() {
        return org.tensorflow.framework.GraphProtos.internal_static_tensorflow_GraphDef_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
    internalGetFieldAccessorTable() {
        return org.tensorflow.framework.GraphProtos.internal_static_tensorflow_GraphDef_fieldAccessorTable
                .ensureFieldAccessorsInitialized(
                        org.tensorflow.framework.GraphDef.class, org.tensorflow.framework.GraphDef.Builder.class);
    }

    public static final int NODE_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private java.util.List<org.tensorflow.framework.NodeDef> node_;

    /**
     * <code>repeated .tensorflow.NodeDef node = 1;</code>
     */
    @java.lang.Override
    public java.util.List<org.tensorflow.framework.NodeDef> getNodeList() {
        return node_;
    }

    /**
     * <code>repeated .tensorflow.NodeDef node = 1;</code>
     */
    @java.lang.Override
    public java.util.List<? extends org.tensorflow.framework.NodeDefOrBuilder>
    getNodeOrBuilderList() {
        return node_;
    }

    /**
     * <code>repeated .tensorflow.NodeDef node = 1;</code>
     */
    @java.lang.Override
    public int getNodeCount() {
        return node_.size();
    }

    /**
     * <code>repeated .tensorflow.NodeDef node = 1;</code>
     */
    @java.lang.Override
    public org.tensorflow.framework.NodeDef getNode(int index) {
        return node_.get(index);
    }

    /**
     * <code>repeated .tensorflow.NodeDef node = 1;</code>
     */
    @java.lang.Override
    public org.tensorflow.framework.NodeDefOrBuilder getNodeOrBuilder(
            int index) {
        return node_.get(index);
    }

    public static final int VERSIONS_FIELD_NUMBER = 4;
    private org.tensorflow.framework.VersionDef versions_;

    /**
     * <pre>
     * Compatibility versions of the graph.  See core/public/version.h for version
     * history.  The GraphDef version is distinct from the TensorFlow version, and
     * each release of TensorFlow will support a range of GraphDef versions.
     * </pre>
     *
     * <code>.tensorflow.VersionDef versions = 4;</code>
     *
     * @return Whether the versions field is set.
     */
    @java.lang.Override
    public boolean hasVersions() {
        return versions_ != null;
    }

    /**
     * <pre>
     * Compatibility versions of the graph.  See core/public/version.h for version
     * history.  The GraphDef version is distinct from the TensorFlow version, and
     * each release of TensorFlow will support a range of GraphDef versions.
     * </pre>
     *
     * <code>.tensorflow.VersionDef versions = 4;</code>
     *
     * @return The versions.
     */
    @java.lang.Override
    public org.tensorflow.framework.VersionDef getVersions() {
        return versions_ == null ? org.tensorflow.framework.VersionDef.getDefaultInstance() : versions_;
    }

    /**
     * <pre>
     * Compatibility versions of the graph.  See core/public/version.h for version
     * history.  The GraphDef version is distinct from the TensorFlow version, and
     * each release of TensorFlow will support a range of GraphDef versions.
     * </pre>
     *
     * <code>.tensorflow.VersionDef versions = 4;</code>
     */
    @java.lang.Override
    public org.tensorflow.framework.VersionDefOrBuilder getVersionsOrBuilder() {
        return versions_ == null ? org.tensorflow.framework.VersionDef.getDefaultInstance() : versions_;
    }

    public static final int VERSION_FIELD_NUMBER = 3;
    private int version_ = 0;

    /**
     * <pre>
     * Deprecated single version field; use versions above instead.  Since all
     * GraphDef changes before "versions" was introduced were forward
     * compatible, this field is entirely ignored.
     * </pre>
     *
     * <code>int32 version = 3 [deprecated = true];</code>
     *
     * @return The version.
     * @deprecated tensorflow.GraphDef.version is deprecated.
     * See tensorflow/core/framework/graph.proto;l=24
     */
    @java.lang.Override
    @java.lang.Deprecated
    public int getVersion() {
        return version_;
    }

    public static final int LIBRARY_FIELD_NUMBER = 2;
    private org.tensorflow.framework.FunctionDefLibrary library_;

    /**
     * <pre>
     * EXPERIMENTAL. DO NOT USE OR DEPEND ON THIS YET.
     * "library" provides user-defined functions.
     * Naming:
     *   * library.function.name are in a flat namespace.
     *     NOTE: We may need to change it to be hierarchical to support
     *     different orgs. E.g.,
     *     { "/google/nn", { ... }},
     *     { "/google/vision", { ... }}
     *     { "/org_foo/module_bar", { ... }}
     *     map&lt;string, FunctionDefLib&gt; named_lib;
     *   * If node[i].op is the name of one function in "library",
     *     node[i] is deemed as a function call. Otherwise, node[i].op
     *     must be a primitive operation supported by the runtime.
     * Function call semantics:
     *   * The callee may start execution as soon as some of its inputs
     *     are ready. The caller may want to use Tuple() mechanism to
     *     ensure all inputs are ready in the same time.
     *   * The consumer of return values may start executing as soon as
     *     the return values the consumer depends on are ready.  The
     *     consumer may want to use Tuple() mechanism to ensure the
     *     consumer does not start until all return values of the callee
     *     function are ready.
     * </pre>
     *
     * <code>.tensorflow.FunctionDefLibrary library = 2;</code>
     *
     * @return Whether the library field is set.
     */
    @java.lang.Override
    public boolean hasLibrary() {
        return library_ != null;
    }

    /**
     * <pre>
     * EXPERIMENTAL. DO NOT USE OR DEPEND ON THIS YET.
     * "library" provides user-defined functions.
     * Naming:
     *   * library.function.name are in a flat namespace.
     *     NOTE: We may need to change it to be hierarchical to support
     *     different orgs. E.g.,
     *     { "/google/nn", { ... }},
     *     { "/google/vision", { ... }}
     *     { "/org_foo/module_bar", { ... }}
     *     map&lt;string, FunctionDefLib&gt; named_lib;
     *   * If node[i].op is the name of one function in "library",
     *     node[i] is deemed as a function call. Otherwise, node[i].op
     *     must be a primitive operation supported by the runtime.
     * Function call semantics:
     *   * The callee may start execution as soon as some of its inputs
     *     are ready. The caller may want to use Tuple() mechanism to
     *     ensure all inputs are ready in the same time.
     *   * The consumer of return values may start executing as soon as
     *     the return values the consumer depends on are ready.  The
     *     consumer may want to use Tuple() mechanism to ensure the
     *     consumer does not start until all return values of the callee
     *     function are ready.
     * </pre>
     *
     * <code>.tensorflow.FunctionDefLibrary library = 2;</code>
     *
     * @return The library.
     */
    @java.lang.Override
    public org.tensorflow.framework.FunctionDefLibrary getLibrary() {
        return library_ == null ? org.tensorflow.framework.FunctionDefLibrary.getDefaultInstance() : library_;
    }

    /**
     * <pre>
     * EXPERIMENTAL. DO NOT USE OR DEPEND ON THIS YET.
     * "library" provides user-defined functions.
     * Naming:
     *   * library.function.name are in a flat namespace.
     *     NOTE: We may need to change it to be hierarchical to support
     *     different orgs. E.g.,
     *     { "/google/nn", { ... }},
     *     { "/google/vision", { ... }}
     *     { "/org_foo/module_bar", { ... }}
     *     map&lt;string, FunctionDefLib&gt; named_lib;
     *   * If node[i].op is the name of one function in "library",
     *     node[i] is deemed as a function call. Otherwise, node[i].op
     *     must be a primitive operation supported by the runtime.
     * Function call semantics:
     *   * The callee may start execution as soon as some of its inputs
     *     are ready. The caller may want to use Tuple() mechanism to
     *     ensure all inputs are ready in the same time.
     *   * The consumer of return values may start executing as soon as
     *     the return values the consumer depends on are ready.  The
     *     consumer may want to use Tuple() mechanism to ensure the
     *     consumer does not start until all return values of the callee
     *     function are ready.
     * </pre>
     *
     * <code>.tensorflow.FunctionDefLibrary library = 2;</code>
     */
    @java.lang.Override
    public org.tensorflow.framework.FunctionDefLibraryOrBuilder getLibraryOrBuilder() {
        return library_ == null ? org.tensorflow.framework.FunctionDefLibrary.getDefaultInstance() : library_;
    }

    private byte memoizedIsInitialized = -1;

    @java.lang.Override
    public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
            throws java.io.IOException {
        for (int i = 0; i < node_.size(); i++) {
            output.writeMessage(1, node_.get(i));
        }
        if (library_ != null) {
            output.writeMessage(2, getLibrary());
        }
        if (version_ != 0) {
            output.writeInt32(3, version_);
        }
        if (versions_ != null) {
            output.writeMessage(4, getVersions());
        }
        getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        for (int i = 0; i < node_.size(); i++) {
            size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(1, node_.get(i));
        }
        if (library_ != null) {
            size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(2, getLibrary());
        }
        if (version_ != 0) {
            size += com.google.protobuf.CodedOutputStream
                    .computeInt32Size(3, version_);
        }
        if (versions_ != null) {
            size += com.google.protobuf.CodedOutputStream
                    .computeMessageSize(4, getVersions());
        }
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
            return true;
        }
        if (!(obj instanceof org.tensorflow.framework.GraphDef)) {
            return super.equals(obj);
        }
        org.tensorflow.framework.GraphDef other = (org.tensorflow.framework.GraphDef) obj;

        if (!getNodeList()
                .equals(other.getNodeList())) return false;
        if (hasVersions() != other.hasVersions()) return false;
        if (hasVersions()) {
            if (!getVersions()
                    .equals(other.getVersions())) return false;
        }
        if (getVersion()
            != other.getVersion()) return false;
        if (hasLibrary() != other.hasLibrary()) return false;
        if (hasLibrary()) {
            if (!getLibrary()
                    .equals(other.getLibrary())) return false;
        }
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
    }

    @java.lang.Override
    public int hashCode() {
        if (memoizedHashCode != 0) {
            return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (getNodeCount() > 0) {
            hash = (37 * hash) + NODE_FIELD_NUMBER;
            hash = (53 * hash) + getNodeList().hashCode();
        }
        if (hasVersions()) {
            hash = (37 * hash) + VERSIONS_FIELD_NUMBER;
            hash = (53 * hash) + getVersions().hashCode();
        }
        hash = (37 * hash) + VERSION_FIELD_NUMBER;
        hash = (53 * hash) + getVersion();
        if (hasLibrary()) {
            hash = (37 * hash) + LIBRARY_FIELD_NUMBER;
            hash = (53 * hash) + getLibrary().hashCode();
        }
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
    }

    public static org.tensorflow.framework.GraphDef parseFrom(
            java.nio.ByteBuffer data)
            throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
    }

    public static org.tensorflow.framework.GraphDef parseFrom(
            java.nio.ByteBuffer data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
    }

    public static org.tensorflow.framework.GraphDef parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
    }

    public static org.tensorflow.framework.GraphDef parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
    }

    public static org.tensorflow.framework.GraphDef parseFrom(byte[] data)
            throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
    }

    public static org.tensorflow.framework.GraphDef parseFrom(
            byte[] data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
    }

    public static org.tensorflow.framework.GraphDef parseFrom(java.io.InputStream input)
            throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
                .parseWithIOException(PARSER, input);
    }

    public static org.tensorflow.framework.GraphDef parseFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
                .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static org.tensorflow.framework.GraphDef parseDelimitedFrom(java.io.InputStream input)
            throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
                .parseDelimitedWithIOException(PARSER, input);
    }

    public static org.tensorflow.framework.GraphDef parseDelimitedFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
                .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }

    public static org.tensorflow.framework.GraphDef parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
                .parseWithIOException(PARSER, input);
    }

    public static org.tensorflow.framework.GraphDef parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
                .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() {return newBuilder();}

    public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
    }

    public static Builder newBuilder(org.tensorflow.framework.GraphDef prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    @java.lang.Override
    public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
                ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
    }

    /**
     * <pre>
     * Represents the graph of operations
     * </pre>
     * <p>
     * Protobuf type {@code tensorflow.GraphDef}
     */
    public static final class Builder extends
                                      com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
                                                                                              // @@protoc_insertion_point(builder_implements:tensorflow.GraphDef)
                                                                                                      org.tensorflow.framework.GraphDefOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
            return org.tensorflow.framework.GraphProtos.internal_static_tensorflow_GraphDef_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
            return org.tensorflow.framework.GraphProtos.internal_static_tensorflow_GraphDef_fieldAccessorTable
                    .ensureFieldAccessorsInitialized(
                            org.tensorflow.framework.GraphDef.class, org.tensorflow.framework.GraphDef.Builder.class);
        }

        // Construct using org.tensorflow.framework.GraphDef.newBuilder()
        private Builder() {

        }

        private Builder(
                com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
            super(parent);

        }

        @java.lang.Override
        public Builder clear() {
            super.clear();
            bitField0_ = 0;
            if (nodeBuilder_ == null) {
                node_ = java.util.Collections.emptyList();
            } else {
                node_ = null;
                nodeBuilder_.clear();
            }
            bitField0_ = (bitField0_ & ~0x00000001);
            versions_ = null;
            if (versionsBuilder_ != null) {
                versionsBuilder_.dispose();
                versionsBuilder_ = null;
            }
            version_ = 0;
            library_ = null;
            if (libraryBuilder_ != null) {
                libraryBuilder_.dispose();
                libraryBuilder_ = null;
            }
            return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
        getDescriptorForType() {
            return org.tensorflow.framework.GraphProtos.internal_static_tensorflow_GraphDef_descriptor;
        }

        @java.lang.Override
        public org.tensorflow.framework.GraphDef getDefaultInstanceForType() {
            return org.tensorflow.framework.GraphDef.getDefaultInstance();
        }

        @java.lang.Override
        public org.tensorflow.framework.GraphDef build() {
            org.tensorflow.framework.GraphDef result = buildPartial();
            if (!result.isInitialized()) {
                throw newUninitializedMessageException(result);
            }
            return result;
        }

        @java.lang.Override
        public org.tensorflow.framework.GraphDef buildPartial() {
            org.tensorflow.framework.GraphDef result = new org.tensorflow.framework.GraphDef(this);
            buildPartialRepeatedFields(result);
            if (bitField0_ != 0) {
                buildPartial0(result);
            }
            onBuilt();
            return result;
        }

        private void buildPartialRepeatedFields(org.tensorflow.framework.GraphDef result) {
            if (nodeBuilder_ == null) {
                if (((bitField0_ & 0x00000001) != 0)) {
                    node_ = java.util.Collections.unmodifiableList(node_);
                    bitField0_ = (bitField0_ & ~0x00000001);
                }
                result.node_ = node_;
            } else {
                result.node_ = nodeBuilder_.build();
            }
        }

        private void buildPartial0(org.tensorflow.framework.GraphDef result) {
            int from_bitField0_ = bitField0_;
            if (((from_bitField0_ & 0x00000002) != 0)) {
                result.versions_ = versionsBuilder_ == null
                        ? versions_
                        : versionsBuilder_.build();
            }
            if (((from_bitField0_ & 0x00000004) != 0)) {
                result.version_ = version_;
            }
            if (((from_bitField0_ & 0x00000008) != 0)) {
                result.library_ = libraryBuilder_ == null
                        ? library_
                        : libraryBuilder_.build();
            }
        }

        @java.lang.Override
        public Builder clone() {
            return super.clone();
        }

        @java.lang.Override
        public Builder setField(
                com.google.protobuf.Descriptors.FieldDescriptor field,
                java.lang.Object value) {
            return super.setField(field, value);
        }

        @java.lang.Override
        public Builder clearField(
                com.google.protobuf.Descriptors.FieldDescriptor field) {
            return super.clearField(field);
        }

        @java.lang.Override
        public Builder clearOneof(
                com.google.protobuf.Descriptors.OneofDescriptor oneof) {
            return super.clearOneof(oneof);
        }

        @java.lang.Override
        public Builder setRepeatedField(
                com.google.protobuf.Descriptors.FieldDescriptor field,
                int index, java.lang.Object value) {
            return super.setRepeatedField(field, index, value);
        }

        @java.lang.Override
        public Builder addRepeatedField(
                com.google.protobuf.Descriptors.FieldDescriptor field,
                java.lang.Object value) {
            return super.addRepeatedField(field, value);
        }

        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
            if (other instanceof org.tensorflow.framework.GraphDef) {
                return mergeFrom((org.tensorflow.framework.GraphDef) other);
            } else {
                super.mergeFrom(other);
                return this;
            }
        }

        public Builder mergeFrom(org.tensorflow.framework.GraphDef other) {
            if (other == org.tensorflow.framework.GraphDef.getDefaultInstance()) return this;
            if (nodeBuilder_ == null) {
                if (!other.node_.isEmpty()) {
                    if (node_.isEmpty()) {
                        node_ = other.node_;
                        bitField0_ = (bitField0_ & ~0x00000001);
                    } else {
                        ensureNodeIsMutable();
                        node_.addAll(other.node_);
                    }
                    onChanged();
                }
            } else {
                if (!other.node_.isEmpty()) {
                    if (nodeBuilder_.isEmpty()) {
                        nodeBuilder_.dispose();
                        nodeBuilder_ = null;
                        node_ = other.node_;
                        bitField0_ = (bitField0_ & ~0x00000001);
                        nodeBuilder_ =
                                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                                        getNodeFieldBuilder() : null;
                    } else {
                        nodeBuilder_.addAllMessages(other.node_);
                    }
                }
            }
            if (other.hasVersions()) {
                mergeVersions(other.getVersions());
            }
            if (other.getVersion() != 0) {
                setVersion(other.getVersion());
            }
            if (other.hasLibrary()) {
                mergeLibrary(other.getLibrary());
            }
            this.mergeUnknownFields(other.getUnknownFields());
            onChanged();
            return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
            return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
            if (extensionRegistry == null) {
                throw new java.lang.NullPointerException();
            }
            try {
                boolean done = false;
                while (!done) {
                    int tag = input.readTag();
                    switch (tag) {
                        case 0:
                            done = true;
                            break;
                        case 10: {
                            org.tensorflow.framework.NodeDef m =
                                    input.readMessage(
                                            org.tensorflow.framework.NodeDef.parser(),
                                            extensionRegistry);
                            if (nodeBuilder_ == null) {
                                ensureNodeIsMutable();
                                node_.add(m);
                            } else {
                                nodeBuilder_.addMessage(m);
                            }
                            break;
                        } // case 10
                        case 18: {
                            input.readMessage(
                                    getLibraryFieldBuilder().getBuilder(),
                                    extensionRegistry);
                            bitField0_ |= 0x00000008;
                            break;
                        } // case 18
                        case 24: {
                            version_ = input.readInt32();
                            bitField0_ |= 0x00000004;
                            break;
                        } // case 24
                        case 34: {
                            input.readMessage(
                                    getVersionsFieldBuilder().getBuilder(),
                                    extensionRegistry);
                            bitField0_ |= 0x00000002;
                            break;
                        } // case 34
                        default: {
                            if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                                done = true; // was an endgroup tag
                            }
                            break;
                        } // default:
                    } // switch (tag)
                } // while (!done)
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                throw e.unwrapIOException();
            } finally {
                onChanged();
            } // finally
            return this;
        }

        private int bitField0_;

        private java.util.List<org.tensorflow.framework.NodeDef> node_ =
                java.util.Collections.emptyList();

        private void ensureNodeIsMutable() {
            if (!((bitField0_ & 0x00000001) != 0)) {
                node_ = new java.util.ArrayList<org.tensorflow.framework.NodeDef>(node_);
                bitField0_ |= 0x00000001;
            }
        }

        private com.google.protobuf.RepeatedFieldBuilderV3<
                org.tensorflow.framework.NodeDef, org.tensorflow.framework.NodeDef.Builder, org.tensorflow.framework.NodeDefOrBuilder> nodeBuilder_;

        /**
         * <code>repeated .tensorflow.NodeDef node = 1;</code>
         */
        public java.util.List<org.tensorflow.framework.NodeDef> getNodeList() {
            if (nodeBuilder_ == null) {
                return java.util.Collections.unmodifiableList(node_);
            } else {
                return nodeBuilder_.getMessageList();
            }
        }

        /**
         * <code>repeated .tensorflow.NodeDef node = 1;</code>
         */
        public int getNodeCount() {
            if (nodeBuilder_ == null) {
                return node_.size();
            } else {
                return nodeBuilder_.getCount();
            }
        }

        /**
         * <code>repeated .tensorflow.NodeDef node = 1;</code>
         */
        public org.tensorflow.framework.NodeDef getNode(int index) {
            if (nodeBuilder_ == null) {
                return node_.get(index);
            } else {
                return nodeBuilder_.getMessage(index);
            }
        }

        /**
         * <code>repeated .tensorflow.NodeDef node = 1;</code>
         */
        public Builder setNode(
                int index, org.tensorflow.framework.NodeDef value) {
            if (nodeBuilder_ == null) {
                if (value == null) {
                    throw new NullPointerException();
                }
                ensureNodeIsMutable();
                node_.set(index, value);
                onChanged();
            } else {
                nodeBuilder_.setMessage(index, value);
            }
            return this;
        }

        /**
         * <code>repeated .tensorflow.NodeDef node = 1;</code>
         */
        public Builder setNode(
                int index, org.tensorflow.framework.NodeDef.Builder builderForValue) {
            if (nodeBuilder_ == null) {
                ensureNodeIsMutable();
                node_.set(index, builderForValue.build());
                onChanged();
            } else {
                nodeBuilder_.setMessage(index, builderForValue.build());
            }
            return this;
        }

        /**
         * <code>repeated .tensorflow.NodeDef node = 1;</code>
         */
        public Builder addNode(org.tensorflow.framework.NodeDef value) {
            if (nodeBuilder_ == null) {
                if (value == null) {
                    throw new NullPointerException();
                }
                ensureNodeIsMutable();
                node_.add(value);
                onChanged();
            } else {
                nodeBuilder_.addMessage(value);
            }
            return this;
        }

        /**
         * <code>repeated .tensorflow.NodeDef node = 1;</code>
         */
        public Builder addNode(
                int index, org.tensorflow.framework.NodeDef value) {
            if (nodeBuilder_ == null) {
                if (value == null) {
                    throw new NullPointerException();
                }
                ensureNodeIsMutable();
                node_.add(index, value);
                onChanged();
            } else {
                nodeBuilder_.addMessage(index, value);
            }
            return this;
        }

        /**
         * <code>repeated .tensorflow.NodeDef node = 1;</code>
         */
        public Builder addNode(
                org.tensorflow.framework.NodeDef.Builder builderForValue) {
            if (nodeBuilder_ == null) {
                ensureNodeIsMutable();
                node_.add(builderForValue.build());
                onChanged();
            } else {
                nodeBuilder_.addMessage(builderForValue.build());
            }
            return this;
        }

        /**
         * <code>repeated .tensorflow.NodeDef node = 1;</code>
         */
        public Builder addNode(
                int index, org.tensorflow.framework.NodeDef.Builder builderForValue) {
            if (nodeBuilder_ == null) {
                ensureNodeIsMutable();
                node_.add(index, builderForValue.build());
                onChanged();
            } else {
                nodeBuilder_.addMessage(index, builderForValue.build());
            }
            return this;
        }

        /**
         * <code>repeated .tensorflow.NodeDef node = 1;</code>
         */
        public Builder addAllNode(
                java.lang.Iterable<? extends org.tensorflow.framework.NodeDef> values) {
            if (nodeBuilder_ == null) {
                ensureNodeIsMutable();
                com.google.protobuf.AbstractMessageLite.Builder.addAll(
                        values, node_);
                onChanged();
            } else {
                nodeBuilder_.addAllMessages(values);
            }
            return this;
        }

        /**
         * <code>repeated .tensorflow.NodeDef node = 1;</code>
         */
        public Builder clearNode() {
            if (nodeBuilder_ == null) {
                node_ = java.util.Collections.emptyList();
                bitField0_ = (bitField0_ & ~0x00000001);
                onChanged();
            } else {
                nodeBuilder_.clear();
            }
            return this;
        }

        /**
         * <code>repeated .tensorflow.NodeDef node = 1;</code>
         */
        public Builder removeNode(int index) {
            if (nodeBuilder_ == null) {
                ensureNodeIsMutable();
                node_.remove(index);
                onChanged();
            } else {
                nodeBuilder_.remove(index);
            }
            return this;
        }

        /**
         * <code>repeated .tensorflow.NodeDef node = 1;</code>
         */
        public org.tensorflow.framework.NodeDef.Builder getNodeBuilder(
                int index) {
            return getNodeFieldBuilder().getBuilder(index);
        }

        /**
         * <code>repeated .tensorflow.NodeDef node = 1;</code>
         */
        public org.tensorflow.framework.NodeDefOrBuilder getNodeOrBuilder(
                int index) {
            if (nodeBuilder_ == null) {
                return node_.get(index);
            } else {
                return nodeBuilder_.getMessageOrBuilder(index);
            }
        }

        /**
         * <code>repeated .tensorflow.NodeDef node = 1;</code>
         */
        public java.util.List<? extends org.tensorflow.framework.NodeDefOrBuilder>
        getNodeOrBuilderList() {
            if (nodeBuilder_ != null) {
                return nodeBuilder_.getMessageOrBuilderList();
            } else {
                return java.util.Collections.unmodifiableList(node_);
            }
        }

        /**
         * <code>repeated .tensorflow.NodeDef node = 1;</code>
         */
        public org.tensorflow.framework.NodeDef.Builder addNodeBuilder() {
            return getNodeFieldBuilder().addBuilder(
                    org.tensorflow.framework.NodeDef.getDefaultInstance());
        }

        /**
         * <code>repeated .tensorflow.NodeDef node = 1;</code>
         */
        public org.tensorflow.framework.NodeDef.Builder addNodeBuilder(
                int index) {
            return getNodeFieldBuilder().addBuilder(
                    index, org.tensorflow.framework.NodeDef.getDefaultInstance());
        }

        /**
         * <code>repeated .tensorflow.NodeDef node = 1;</code>
         */
        public java.util.List<org.tensorflow.framework.NodeDef.Builder>
        getNodeBuilderList() {
            return getNodeFieldBuilder().getBuilderList();
        }

        private com.google.protobuf.RepeatedFieldBuilderV3<
                org.tensorflow.framework.NodeDef, org.tensorflow.framework.NodeDef.Builder, org.tensorflow.framework.NodeDefOrBuilder>
        getNodeFieldBuilder() {
            if (nodeBuilder_ == null) {
                nodeBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
                        org.tensorflow.framework.NodeDef, org.tensorflow.framework.NodeDef.Builder, org.tensorflow.framework.NodeDefOrBuilder>(
                        node_,
                        ((bitField0_ & 0x00000001) != 0),
                        getParentForChildren(),
                        isClean());
                node_ = null;
            }
            return nodeBuilder_;
        }

        private org.tensorflow.framework.VersionDef versions_;
        private com.google.protobuf.SingleFieldBuilderV3<
                org.tensorflow.framework.VersionDef, org.tensorflow.framework.VersionDef.Builder, org.tensorflow.framework.VersionDefOrBuilder> versionsBuilder_;

        /**
         * <pre>
         * Compatibility versions of the graph.  See core/public/version.h for version
         * history.  The GraphDef version is distinct from the TensorFlow version, and
         * each release of TensorFlow will support a range of GraphDef versions.
         * </pre>
         *
         * <code>.tensorflow.VersionDef versions = 4;</code>
         *
         * @return Whether the versions field is set.
         */
        public boolean hasVersions() {
            return ((bitField0_ & 0x00000002) != 0);
        }

        /**
         * <pre>
         * Compatibility versions of the graph.  See core/public/version.h for version
         * history.  The GraphDef version is distinct from the TensorFlow version, and
         * each release of TensorFlow will support a range of GraphDef versions.
         * </pre>
         *
         * <code>.tensorflow.VersionDef versions = 4;</code>
         *
         * @return The versions.
         */
        public org.tensorflow.framework.VersionDef getVersions() {
            if (versionsBuilder_ == null) {
                return versions_ == null ? org.tensorflow.framework.VersionDef.getDefaultInstance() : versions_;
            } else {
                return versionsBuilder_.getMessage();
            }
        }

        /**
         * <pre>
         * Compatibility versions of the graph.  See core/public/version.h for version
         * history.  The GraphDef version is distinct from the TensorFlow version, and
         * each release of TensorFlow will support a range of GraphDef versions.
         * </pre>
         *
         * <code>.tensorflow.VersionDef versions = 4;</code>
         */
        public Builder setVersions(org.tensorflow.framework.VersionDef value) {
            if (versionsBuilder_ == null) {
                if (value == null) {
                    throw new NullPointerException();
                }
                versions_ = value;
            } else {
                versionsBuilder_.setMessage(value);
            }
            bitField0_ |= 0x00000002;
            onChanged();
            return this;
        }

        /**
         * <pre>
         * Compatibility versions of the graph.  See core/public/version.h for version
         * history.  The GraphDef version is distinct from the TensorFlow version, and
         * each release of TensorFlow will support a range of GraphDef versions.
         * </pre>
         *
         * <code>.tensorflow.VersionDef versions = 4;</code>
         */
        public Builder setVersions(
                org.tensorflow.framework.VersionDef.Builder builderForValue) {
            if (versionsBuilder_ == null) {
                versions_ = builderForValue.build();
            } else {
                versionsBuilder_.setMessage(builderForValue.build());
            }
            bitField0_ |= 0x00000002;
            onChanged();
            return this;
        }

        /**
         * <pre>
         * Compatibility versions of the graph.  See core/public/version.h for version
         * history.  The GraphDef version is distinct from the TensorFlow version, and
         * each release of TensorFlow will support a range of GraphDef versions.
         * </pre>
         *
         * <code>.tensorflow.VersionDef versions = 4;</code>
         */
        public Builder mergeVersions(org.tensorflow.framework.VersionDef value) {
            if (versionsBuilder_ == null) {
                if (((bitField0_ & 0x00000002) != 0) &&
                    versions_ != null &&
                    versions_ != org.tensorflow.framework.VersionDef.getDefaultInstance()) {
                    getVersionsBuilder().mergeFrom(value);
                } else {
                    versions_ = value;
                }
            } else {
                versionsBuilder_.mergeFrom(value);
            }
            bitField0_ |= 0x00000002;
            onChanged();
            return this;
        }

        /**
         * <pre>
         * Compatibility versions of the graph.  See core/public/version.h for version
         * history.  The GraphDef version is distinct from the TensorFlow version, and
         * each release of TensorFlow will support a range of GraphDef versions.
         * </pre>
         *
         * <code>.tensorflow.VersionDef versions = 4;</code>
         */
        public Builder clearVersions() {
            bitField0_ = (bitField0_ & ~0x00000002);
            versions_ = null;
            if (versionsBuilder_ != null) {
                versionsBuilder_.dispose();
                versionsBuilder_ = null;
            }
            onChanged();
            return this;
        }

        /**
         * <pre>
         * Compatibility versions of the graph.  See core/public/version.h for version
         * history.  The GraphDef version is distinct from the TensorFlow version, and
         * each release of TensorFlow will support a range of GraphDef versions.
         * </pre>
         *
         * <code>.tensorflow.VersionDef versions = 4;</code>
         */
        public org.tensorflow.framework.VersionDef.Builder getVersionsBuilder() {
            bitField0_ |= 0x00000002;
            onChanged();
            return getVersionsFieldBuilder().getBuilder();
        }

        /**
         * <pre>
         * Compatibility versions of the graph.  See core/public/version.h for version
         * history.  The GraphDef version is distinct from the TensorFlow version, and
         * each release of TensorFlow will support a range of GraphDef versions.
         * </pre>
         *
         * <code>.tensorflow.VersionDef versions = 4;</code>
         */
        public org.tensorflow.framework.VersionDefOrBuilder getVersionsOrBuilder() {
            if (versionsBuilder_ != null) {
                return versionsBuilder_.getMessageOrBuilder();
            } else {
                return versions_ == null ?
                        org.tensorflow.framework.VersionDef.getDefaultInstance() : versions_;
            }
        }

        /**
         * <pre>
         * Compatibility versions of the graph.  See core/public/version.h for version
         * history.  The GraphDef version is distinct from the TensorFlow version, and
         * each release of TensorFlow will support a range of GraphDef versions.
         * </pre>
         *
         * <code>.tensorflow.VersionDef versions = 4;</code>
         */
        private com.google.protobuf.SingleFieldBuilderV3<
                org.tensorflow.framework.VersionDef, org.tensorflow.framework.VersionDef.Builder, org.tensorflow.framework.VersionDefOrBuilder>
        getVersionsFieldBuilder() {
            if (versionsBuilder_ == null) {
                versionsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                        org.tensorflow.framework.VersionDef, org.tensorflow.framework.VersionDef.Builder, org.tensorflow.framework.VersionDefOrBuilder>(
                        getVersions(),
                        getParentForChildren(),
                        isClean());
                versions_ = null;
            }
            return versionsBuilder_;
        }

        private int version_;

        /**
         * <pre>
         * Deprecated single version field; use versions above instead.  Since all
         * GraphDef changes before "versions" was introduced were forward
         * compatible, this field is entirely ignored.
         * </pre>
         *
         * <code>int32 version = 3 [deprecated = true];</code>
         *
         * @return The version.
         * @deprecated tensorflow.GraphDef.version is deprecated.
         * See tensorflow/core/framework/graph.proto;l=24
         */
        @java.lang.Override
        @java.lang.Deprecated
        public int getVersion() {
            return version_;
        }

        /**
         * <pre>
         * Deprecated single version field; use versions above instead.  Since all
         * GraphDef changes before "versions" was introduced were forward
         * compatible, this field is entirely ignored.
         * </pre>
         *
         * <code>int32 version = 3 [deprecated = true];</code>
         *
         * @param value The version to set.
         * @return This builder for chaining.
         * @deprecated tensorflow.GraphDef.version is deprecated.
         * See tensorflow/core/framework/graph.proto;l=24
         */
        @java.lang.Deprecated
        public Builder setVersion(int value) {

            version_ = value;
            bitField0_ |= 0x00000004;
            onChanged();
            return this;
        }

        /**
         * <pre>
         * Deprecated single version field; use versions above instead.  Since all
         * GraphDef changes before "versions" was introduced were forward
         * compatible, this field is entirely ignored.
         * </pre>
         *
         * <code>int32 version = 3 [deprecated = true];</code>
         *
         * @return This builder for chaining.
         * @deprecated tensorflow.GraphDef.version is deprecated.
         * See tensorflow/core/framework/graph.proto;l=24
         */
        @java.lang.Deprecated
        public Builder clearVersion() {
            bitField0_ = (bitField0_ & ~0x00000004);
            version_ = 0;
            onChanged();
            return this;
        }

        private org.tensorflow.framework.FunctionDefLibrary library_;
        private com.google.protobuf.SingleFieldBuilderV3<
                org.tensorflow.framework.FunctionDefLibrary, org.tensorflow.framework.FunctionDefLibrary.Builder, org.tensorflow.framework.FunctionDefLibraryOrBuilder> libraryBuilder_;

        /**
         * <pre>
         * EXPERIMENTAL. DO NOT USE OR DEPEND ON THIS YET.
         * "library" provides user-defined functions.
         * Naming:
         *   * library.function.name are in a flat namespace.
         *     NOTE: We may need to change it to be hierarchical to support
         *     different orgs. E.g.,
         *     { "/google/nn", { ... }},
         *     { "/google/vision", { ... }}
         *     { "/org_foo/module_bar", { ... }}
         *     map&lt;string, FunctionDefLib&gt; named_lib;
         *   * If node[i].op is the name of one function in "library",
         *     node[i] is deemed as a function call. Otherwise, node[i].op
         *     must be a primitive operation supported by the runtime.
         * Function call semantics:
         *   * The callee may start execution as soon as some of its inputs
         *     are ready. The caller may want to use Tuple() mechanism to
         *     ensure all inputs are ready in the same time.
         *   * The consumer of return values may start executing as soon as
         *     the return values the consumer depends on are ready.  The
         *     consumer may want to use Tuple() mechanism to ensure the
         *     consumer does not start until all return values of the callee
         *     function are ready.
         * </pre>
         *
         * <code>.tensorflow.FunctionDefLibrary library = 2;</code>
         *
         * @return Whether the library field is set.
         */
        public boolean hasLibrary() {
            return ((bitField0_ & 0x00000008) != 0);
        }

        /**
         * <pre>
         * EXPERIMENTAL. DO NOT USE OR DEPEND ON THIS YET.
         * "library" provides user-defined functions.
         * Naming:
         *   * library.function.name are in a flat namespace.
         *     NOTE: We may need to change it to be hierarchical to support
         *     different orgs. E.g.,
         *     { "/google/nn", { ... }},
         *     { "/google/vision", { ... }}
         *     { "/org_foo/module_bar", { ... }}
         *     map&lt;string, FunctionDefLib&gt; named_lib;
         *   * If node[i].op is the name of one function in "library",
         *     node[i] is deemed as a function call. Otherwise, node[i].op
         *     must be a primitive operation supported by the runtime.
         * Function call semantics:
         *   * The callee may start execution as soon as some of its inputs
         *     are ready. The caller may want to use Tuple() mechanism to
         *     ensure all inputs are ready in the same time.
         *   * The consumer of return values may start executing as soon as
         *     the return values the consumer depends on are ready.  The
         *     consumer may want to use Tuple() mechanism to ensure the
         *     consumer does not start until all return values of the callee
         *     function are ready.
         * </pre>
         *
         * <code>.tensorflow.FunctionDefLibrary library = 2;</code>
         *
         * @return The library.
         */
        public org.tensorflow.framework.FunctionDefLibrary getLibrary() {
            if (libraryBuilder_ == null) {
                return library_ == null ? org.tensorflow.framework.FunctionDefLibrary.getDefaultInstance() : library_;
            } else {
                return libraryBuilder_.getMessage();
            }
        }

        /**
         * <pre>
         * EXPERIMENTAL. DO NOT USE OR DEPEND ON THIS YET.
         * "library" provides user-defined functions.
         * Naming:
         *   * library.function.name are in a flat namespace.
         *     NOTE: We may need to change it to be hierarchical to support
         *     different orgs. E.g.,
         *     { "/google/nn", { ... }},
         *     { "/google/vision", { ... }}
         *     { "/org_foo/module_bar", { ... }}
         *     map&lt;string, FunctionDefLib&gt; named_lib;
         *   * If node[i].op is the name of one function in "library",
         *     node[i] is deemed as a function call. Otherwise, node[i].op
         *     must be a primitive operation supported by the runtime.
         * Function call semantics:
         *   * The callee may start execution as soon as some of its inputs
         *     are ready. The caller may want to use Tuple() mechanism to
         *     ensure all inputs are ready in the same time.
         *   * The consumer of return values may start executing as soon as
         *     the return values the consumer depends on are ready.  The
         *     consumer may want to use Tuple() mechanism to ensure the
         *     consumer does not start until all return values of the callee
         *     function are ready.
         * </pre>
         *
         * <code>.tensorflow.FunctionDefLibrary library = 2;</code>
         */
        public Builder setLibrary(org.tensorflow.framework.FunctionDefLibrary value) {
            if (libraryBuilder_ == null) {
                if (value == null) {
                    throw new NullPointerException();
                }
                library_ = value;
            } else {
                libraryBuilder_.setMessage(value);
            }
            bitField0_ |= 0x00000008;
            onChanged();
            return this;
        }

        /**
         * <pre>
         * EXPERIMENTAL. DO NOT USE OR DEPEND ON THIS YET.
         * "library" provides user-defined functions.
         * Naming:
         *   * library.function.name are in a flat namespace.
         *     NOTE: We may need to change it to be hierarchical to support
         *     different orgs. E.g.,
         *     { "/google/nn", { ... }},
         *     { "/google/vision", { ... }}
         *     { "/org_foo/module_bar", { ... }}
         *     map&lt;string, FunctionDefLib&gt; named_lib;
         *   * If node[i].op is the name of one function in "library",
         *     node[i] is deemed as a function call. Otherwise, node[i].op
         *     must be a primitive operation supported by the runtime.
         * Function call semantics:
         *   * The callee may start execution as soon as some of its inputs
         *     are ready. The caller may want to use Tuple() mechanism to
         *     ensure all inputs are ready in the same time.
         *   * The consumer of return values may start executing as soon as
         *     the return values the consumer depends on are ready.  The
         *     consumer may want to use Tuple() mechanism to ensure the
         *     consumer does not start until all return values of the callee
         *     function are ready.
         * </pre>
         *
         * <code>.tensorflow.FunctionDefLibrary library = 2;</code>
         */
        public Builder setLibrary(
                org.tensorflow.framework.FunctionDefLibrary.Builder builderForValue) {
            if (libraryBuilder_ == null) {
                library_ = builderForValue.build();
            } else {
                libraryBuilder_.setMessage(builderForValue.build());
            }
            bitField0_ |= 0x00000008;
            onChanged();
            return this;
        }

        /**
         * <pre>
         * EXPERIMENTAL. DO NOT USE OR DEPEND ON THIS YET.
         * "library" provides user-defined functions.
         * Naming:
         *   * library.function.name are in a flat namespace.
         *     NOTE: We may need to change it to be hierarchical to support
         *     different orgs. E.g.,
         *     { "/google/nn", { ... }},
         *     { "/google/vision", { ... }}
         *     { "/org_foo/module_bar", { ... }}
         *     map&lt;string, FunctionDefLib&gt; named_lib;
         *   * If node[i].op is the name of one function in "library",
         *     node[i] is deemed as a function call. Otherwise, node[i].op
         *     must be a primitive operation supported by the runtime.
         * Function call semantics:
         *   * The callee may start execution as soon as some of its inputs
         *     are ready. The caller may want to use Tuple() mechanism to
         *     ensure all inputs are ready in the same time.
         *   * The consumer of return values may start executing as soon as
         *     the return values the consumer depends on are ready.  The
         *     consumer may want to use Tuple() mechanism to ensure the
         *     consumer does not start until all return values of the callee
         *     function are ready.
         * </pre>
         *
         * <code>.tensorflow.FunctionDefLibrary library = 2;</code>
         */
        public Builder mergeLibrary(org.tensorflow.framework.FunctionDefLibrary value) {
            if (libraryBuilder_ == null) {
                if (((bitField0_ & 0x00000008) != 0) &&
                    library_ != null &&
                    library_ != org.tensorflow.framework.FunctionDefLibrary.getDefaultInstance()) {
                    getLibraryBuilder().mergeFrom(value);
                } else {
                    library_ = value;
                }
            } else {
                libraryBuilder_.mergeFrom(value);
            }
            bitField0_ |= 0x00000008;
            onChanged();
            return this;
        }

        /**
         * <pre>
         * EXPERIMENTAL. DO NOT USE OR DEPEND ON THIS YET.
         * "library" provides user-defined functions.
         * Naming:
         *   * library.function.name are in a flat namespace.
         *     NOTE: We may need to change it to be hierarchical to support
         *     different orgs. E.g.,
         *     { "/google/nn", { ... }},
         *     { "/google/vision", { ... }}
         *     { "/org_foo/module_bar", { ... }}
         *     map&lt;string, FunctionDefLib&gt; named_lib;
         *   * If node[i].op is the name of one function in "library",
         *     node[i] is deemed as a function call. Otherwise, node[i].op
         *     must be a primitive operation supported by the runtime.
         * Function call semantics:
         *   * The callee may start execution as soon as some of its inputs
         *     are ready. The caller may want to use Tuple() mechanism to
         *     ensure all inputs are ready in the same time.
         *   * The consumer of return values may start executing as soon as
         *     the return values the consumer depends on are ready.  The
         *     consumer may want to use Tuple() mechanism to ensure the
         *     consumer does not start until all return values of the callee
         *     function are ready.
         * </pre>
         *
         * <code>.tensorflow.FunctionDefLibrary library = 2;</code>
         */
        public Builder clearLibrary() {
            bitField0_ = (bitField0_ & ~0x00000008);
            library_ = null;
            if (libraryBuilder_ != null) {
                libraryBuilder_.dispose();
                libraryBuilder_ = null;
            }
            onChanged();
            return this;
        }

        /**
         * <pre>
         * EXPERIMENTAL. DO NOT USE OR DEPEND ON THIS YET.
         * "library" provides user-defined functions.
         * Naming:
         *   * library.function.name are in a flat namespace.
         *     NOTE: We may need to change it to be hierarchical to support
         *     different orgs. E.g.,
         *     { "/google/nn", { ... }},
         *     { "/google/vision", { ... }}
         *     { "/org_foo/module_bar", { ... }}
         *     map&lt;string, FunctionDefLib&gt; named_lib;
         *   * If node[i].op is the name of one function in "library",
         *     node[i] is deemed as a function call. Otherwise, node[i].op
         *     must be a primitive operation supported by the runtime.
         * Function call semantics:
         *   * The callee may start execution as soon as some of its inputs
         *     are ready. The caller may want to use Tuple() mechanism to
         *     ensure all inputs are ready in the same time.
         *   * The consumer of return values may start executing as soon as
         *     the return values the consumer depends on are ready.  The
         *     consumer may want to use Tuple() mechanism to ensure the
         *     consumer does not start until all return values of the callee
         *     function are ready.
         * </pre>
         *
         * <code>.tensorflow.FunctionDefLibrary library = 2;</code>
         */
        public org.tensorflow.framework.FunctionDefLibrary.Builder getLibraryBuilder() {
            bitField0_ |= 0x00000008;
            onChanged();
            return getLibraryFieldBuilder().getBuilder();
        }

        /**
         * <pre>
         * EXPERIMENTAL. DO NOT USE OR DEPEND ON THIS YET.
         * "library" provides user-defined functions.
         * Naming:
         *   * library.function.name are in a flat namespace.
         *     NOTE: We may need to change it to be hierarchical to support
         *     different orgs. E.g.,
         *     { "/google/nn", { ... }},
         *     { "/google/vision", { ... }}
         *     { "/org_foo/module_bar", { ... }}
         *     map&lt;string, FunctionDefLib&gt; named_lib;
         *   * If node[i].op is the name of one function in "library",
         *     node[i] is deemed as a function call. Otherwise, node[i].op
         *     must be a primitive operation supported by the runtime.
         * Function call semantics:
         *   * The callee may start execution as soon as some of its inputs
         *     are ready. The caller may want to use Tuple() mechanism to
         *     ensure all inputs are ready in the same time.
         *   * The consumer of return values may start executing as soon as
         *     the return values the consumer depends on are ready.  The
         *     consumer may want to use Tuple() mechanism to ensure the
         *     consumer does not start until all return values of the callee
         *     function are ready.
         * </pre>
         *
         * <code>.tensorflow.FunctionDefLibrary library = 2;</code>
         */
        public org.tensorflow.framework.FunctionDefLibraryOrBuilder getLibraryOrBuilder() {
            if (libraryBuilder_ != null) {
                return libraryBuilder_.getMessageOrBuilder();
            } else {
                return library_ == null ?
                        org.tensorflow.framework.FunctionDefLibrary.getDefaultInstance() : library_;
            }
        }

        /**
         * <pre>
         * EXPERIMENTAL. DO NOT USE OR DEPEND ON THIS YET.
         * "library" provides user-defined functions.
         * Naming:
         *   * library.function.name are in a flat namespace.
         *     NOTE: We may need to change it to be hierarchical to support
         *     different orgs. E.g.,
         *     { "/google/nn", { ... }},
         *     { "/google/vision", { ... }}
         *     { "/org_foo/module_bar", { ... }}
         *     map&lt;string, FunctionDefLib&gt; named_lib;
         *   * If node[i].op is the name of one function in "library",
         *     node[i] is deemed as a function call. Otherwise, node[i].op
         *     must be a primitive operation supported by the runtime.
         * Function call semantics:
         *   * The callee may start execution as soon as some of its inputs
         *     are ready. The caller may want to use Tuple() mechanism to
         *     ensure all inputs are ready in the same time.
         *   * The consumer of return values may start executing as soon as
         *     the return values the consumer depends on are ready.  The
         *     consumer may want to use Tuple() mechanism to ensure the
         *     consumer does not start until all return values of the callee
         *     function are ready.
         * </pre>
         *
         * <code>.tensorflow.FunctionDefLibrary library = 2;</code>
         */
        private com.google.protobuf.SingleFieldBuilderV3<
                org.tensorflow.framework.FunctionDefLibrary, org.tensorflow.framework.FunctionDefLibrary.Builder, org.tensorflow.framework.FunctionDefLibraryOrBuilder>
        getLibraryFieldBuilder() {
            if (libraryBuilder_ == null) {
                libraryBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                        org.tensorflow.framework.FunctionDefLibrary, org.tensorflow.framework.FunctionDefLibrary.Builder, org.tensorflow.framework.FunctionDefLibraryOrBuilder>(
                        getLibrary(),
                        getParentForChildren(),
                        isClean());
                library_ = null;
            }
            return libraryBuilder_;
        }

        @java.lang.Override
        public final Builder setUnknownFields(
                final com.google.protobuf.UnknownFieldSet unknownFields) {
            return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
                final com.google.protobuf.UnknownFieldSet unknownFields) {
            return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:tensorflow.GraphDef)
    }

    // @@protoc_insertion_point(class_scope:tensorflow.GraphDef)
    private static final org.tensorflow.framework.GraphDef DEFAULT_INSTANCE;

    static {
        DEFAULT_INSTANCE = new org.tensorflow.framework.GraphDef();
    }

    public static org.tensorflow.framework.GraphDef getDefaultInstance() {
        return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<GraphDef>
            PARSER = new com.google.protobuf.AbstractParser<GraphDef>() {
        @java.lang.Override
        public GraphDef parsePartialFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
            Builder builder = newBuilder();
            try {
                builder.mergeFrom(input, extensionRegistry);
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                throw e.setUnfinishedMessage(builder.buildPartial());
            } catch (com.google.protobuf.UninitializedMessageException e) {
                throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
            } catch (java.io.IOException e) {
                throw new com.google.protobuf.InvalidProtocolBufferException(e)
                        .setUnfinishedMessage(builder.buildPartial());
            }
            return builder.buildPartial();
        }
    };

    public static com.google.protobuf.Parser<GraphDef> parser() {
        return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<GraphDef> getParserForType() {
        return PARSER;
    }

    @java.lang.Override
    public org.tensorflow.framework.GraphDef getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
    }

}

